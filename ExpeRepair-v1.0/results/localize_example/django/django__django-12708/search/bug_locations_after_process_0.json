[
    {
        "rel_file_path": "django/db/backends/base/schema.py",
        "abs_file_path": "/home/elloworl/Projects/PycharmProjects/SWE/SWE-bench-ACR/lite_testbed/django__django/setup_django__django__3.1/django/db/backends/base/schema.py",
        "start": 360,
        "end": 393,
        "class_name": "BaseDatabaseSchemaEditor",
        "method_name": "alter_unique_together",
        "code": "360         sql = constraint.create_sql(model, self)\n361         if sql:\n362             self.execute(sql)\n363 \n364     def remove_constraint(self, model, constraint):\n365         \"\"\"Remove a constraint from a model.\"\"\"\n366         sql = constraint.remove_sql(model, self)\n367         if sql:\n368             self.execute(sql)\n369 \n370     def alter_unique_together(self, model, old_unique_together, new_unique_together):\n371         \"\"\"\n372         Deal with a model changing its unique_together. The input\n373         unique_togethers must be doubly-nested, not the single-nested\n374         [\"foo\", \"bar\"] format.\n375         \"\"\"\n376         olds = {tuple(fields) for fields in old_unique_together}\n377         news = {tuple(fields) for fields in new_unique_together}\n378         # Deleted uniques\n379         for fields in olds.difference(news):\n380             self._delete_composed_index(model, fields, {'unique': True}, self.sql_delete_unique)\n381         # Created uniques\n382         for fields in news.difference(olds):\n383             columns = [model._meta.get_field(field).column for field in fields]\n384             self.execute(self._create_unique_sql(model, columns))\n385 \n386     def alter_index_together(self, model, old_index_together, new_index_together):\n387         \"\"\"\n388         Deal with a model changing its index_together. The input\n389         index_togethers must be doubly-nested, not the single-nested\n390         [\"foo\", \"bar\"] format.\n391         \"\"\"\n392         olds = {tuple(fields) for fields in old_index_together}\n393         news = {tuple(fields) for fields in new_index_together}\n",
        "intended_behavior": ""
    },
    {
        "rel_file_path": "django/db/backends/base/schema.py",
        "abs_file_path": "/home/elloworl/Projects/PycharmProjects/SWE/SWE-bench-ACR/lite_testbed/django__django/setup_django__django__3.1/django/db/backends/base/schema.py",
        "start": 376,
        "end": 409,
        "class_name": "BaseDatabaseSchemaEditor",
        "method_name": "alter_index_together",
        "code": "376         olds = {tuple(fields) for fields in old_unique_together}\n377         news = {tuple(fields) for fields in new_unique_together}\n378         # Deleted uniques\n379         for fields in olds.difference(news):\n380             self._delete_composed_index(model, fields, {'unique': True}, self.sql_delete_unique)\n381         # Created uniques\n382         for fields in news.difference(olds):\n383             columns = [model._meta.get_field(field).column for field in fields]\n384             self.execute(self._create_unique_sql(model, columns))\n385 \n386     def alter_index_together(self, model, old_index_together, new_index_together):\n387         \"\"\"\n388         Deal with a model changing its index_together. The input\n389         index_togethers must be doubly-nested, not the single-nested\n390         [\"foo\", \"bar\"] format.\n391         \"\"\"\n392         olds = {tuple(fields) for fields in old_index_together}\n393         news = {tuple(fields) for fields in new_index_together}\n394         # Deleted indexes\n395         for fields in olds.difference(news):\n396             self._delete_composed_index(model, fields, {'index': True}, self.sql_delete_index)\n397         # Created indexes\n398         for field_names in news.difference(olds):\n399             fields = [model._meta.get_field(field) for field in field_names]\n400             self.execute(self._create_index_sql(model, fields, suffix=\"_idx\"))\n401 \n402     def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n403         meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n404         meta_index_names = {constraint.name for constraint in model._meta.indexes}\n405         columns = [model._meta.get_field(field).column for field in fields]\n406         constraint_names = self._constraint_names(\n407             model, columns, exclude=meta_constraint_names | meta_index_names,\n408             **constraint_kwargs\n409         )\n",
        "intended_behavior": ""
    },
    {
        "rel_file_path": "django/db/backends/base/schema.py",
        "abs_file_path": "/home/elloworl/Projects/PycharmProjects/SWE/SWE-bench-ACR/lite_testbed/django__django/setup_django__django__3.1/django/db/backends/base/schema.py",
        "start": 392,
        "end": 425,
        "class_name": "BaseDatabaseSchemaEditor",
        "method_name": "_delete_composed_index",
        "code": "392         olds = {tuple(fields) for fields in old_index_together}\n393         news = {tuple(fields) for fields in new_index_together}\n394         # Deleted indexes\n395         for fields in olds.difference(news):\n396             self._delete_composed_index(model, fields, {'index': True}, self.sql_delete_index)\n397         # Created indexes\n398         for field_names in news.difference(olds):\n399             fields = [model._meta.get_field(field) for field in field_names]\n400             self.execute(self._create_index_sql(model, fields, suffix=\"_idx\"))\n401 \n402     def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n403         meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n404         meta_index_names = {constraint.name for constraint in model._meta.indexes}\n405         columns = [model._meta.get_field(field).column for field in fields]\n406         constraint_names = self._constraint_names(\n407             model, columns, exclude=meta_constraint_names | meta_index_names,\n408             **constraint_kwargs\n409         )\n410         if len(constraint_names) != 1:\n411             raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n412                 len(constraint_names),\n413                 model._meta.db_table,\n414                 \", \".join(columns),\n415             ))\n416         self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n417 \n418     def alter_db_table(self, model, old_db_table, new_db_table):\n419         \"\"\"Rename the table a model points to.\"\"\"\n420         if (old_db_table == new_db_table or\n421             (self.connection.features.ignores_table_name_case and\n422                 old_db_table.lower() == new_db_table.lower())):\n423             return\n424         self.execute(self.sql_rename_table % {\n425             \"old_table\": self.quote_name(old_db_table),\n",
        "intended_behavior": ""
    },
    {
        "rel_file_path": "django/db/backends/mysql/schema.py",
        "abs_file_path": "/home/elloworl/Projects/PycharmProjects/SWE/SWE-bench-ACR/lite_testbed/django__django/setup_django__django__3.1/django/db/backends/mysql/schema.py",
        "start": 105,
        "end": 138,
        "class_name": "DatabaseSchemaEditor",
        "method_name": "_delete_composed_index",
        "code": "105         # No need to create an index for ForeignKey fields except if\n106         # db_constraint=False because the index from that constraint won't be\n107         # created.\n108         if (storage == \"InnoDB\" and\n109                 create_index and\n110                 field.get_internal_type() == 'ForeignKey' and\n111                 field.db_constraint):\n112             return False\n113         return not self._is_limited_data_type(field) and create_index\n114 \n115     def _delete_composed_index(self, model, fields, *args):\n116         \"\"\"\n117         MySQL can remove an implicit FK index on a field when that field is\n118         covered by another index like a unique_together. \"covered\" here means\n119         that the more complex index starts like the simpler one.\n120         http://bugs.mysql.com/bug.php?id=37910 / Django ticket #24757\n121         We check here before removing the [unique|index]_together if we have to\n122         recreate a FK index.\n123         \"\"\"\n124         first_field = model._meta.get_field(fields[0])\n125         if first_field.get_internal_type() == 'ForeignKey':\n126             constraint_names = self._constraint_names(model, [first_field.column], index=True)\n127             if not constraint_names:\n128                 self.execute(self._create_index_sql(model, [first_field], suffix=\"\"))\n129         return super()._delete_composed_index(model, fields, *args)\n130 \n131     def _set_field_new_type_null_status(self, field, new_type):\n132         \"\"\"\n133         Keep the null property of the old field. If it has changed, it will be\n134         handled separately.\n135         \"\"\"\n136         if field.null:\n137             new_type += \" NULL\"\n138         else:\n",
        "intended_behavior": ""
    }
]