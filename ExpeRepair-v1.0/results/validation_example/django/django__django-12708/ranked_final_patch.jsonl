{"model_name_or_path": "ase_0", "instance_id": "django__django-12708", "model_patch": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 61f88401ab..de1d3a93d3 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -377,7 +377,7 @@ class BaseDatabaseSchemaEditor:\n         news = {tuple(fields) for fields in new_unique_together}\n         # Deleted uniques\n         for fields in olds.difference(news):\n-            self._delete_composed_index(model, fields, {'unique': True}, self.sql_delete_unique)\n+            self._delete_composed_index(model, fields, {'unique': True, 'index': False}, self.sql_delete_unique)\n         # Created uniques\n         for fields in news.difference(olds):\n             columns = [model._meta.get_field(field).column for field in fields]\n@@ -393,7 +393,7 @@ class BaseDatabaseSchemaEditor:\n         news = {tuple(fields) for fields in new_index_together}\n         # Deleted indexes\n         for fields in olds.difference(news):\n-            self._delete_composed_index(model, fields, {'index': True}, self.sql_delete_index)\n+            self._delete_composed_index(model, fields, {'index': True, 'unique': False}, self.sql_delete_index)\n         # Created indexes\n         for field_names in news.difference(olds):\n             fields = [model._meta.get_field(field) for field in field_names]\n"}
{"model_name_or_path": "ase_1", "instance_id": "django__django-12708", "model_patch": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 61f88401ab..3b19b49afb 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -391,9 +391,14 @@ class BaseDatabaseSchemaEditor:\n         \"\"\"\n         olds = {tuple(fields) for fields in old_index_together}\n         news = {tuple(fields) for fields in new_index_together}\n+        # Get current unique_together to avoid conflicts\n+        unique_together = {tuple(fields) for fields in model._meta.unique_together}\n         # Deleted indexes\n         for fields in olds.difference(news):\n-            self._delete_composed_index(model, fields, {'index': True}, self.sql_delete_index)\n+            # Skip dropping index if the same fields have a unique_together constraint\n+            # because the unique constraint already provides the indexing\n+            if fields not in unique_together:\n+                self._delete_composed_index(model, fields, {'index': True}, self.sql_delete_index)\n         # Created indexes\n         for field_names in news.difference(olds):\n             fields = [model._meta.get_field(field) for field in field_names]\n"}
{"model_name_or_path": "ase_2", "instance_id": "django__django-12708", "model_patch": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 61f88401ab..4a2fe044b1 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -391,8 +391,13 @@ class BaseDatabaseSchemaEditor:\n         \"\"\"\n         olds = {tuple(fields) for fields in old_index_together}\n         news = {tuple(fields) for fields in new_index_together}\n+        # Any fields still under unique_together provide their own index;\n+        # do not drop them when removing index_together.\n+        unique_together = {tuple(ut) for ut in model._meta.unique_together}\n         # Deleted indexes\n         for fields in olds.difference(news):\n+            if fields in unique_together:\n+                continue\n             self._delete_composed_index(model, fields, {'index': True}, self.sql_delete_index)\n         # Created indexes\n         for field_names in news.difference(olds):\n"}
{"model_name_or_path": "ase_3", "instance_id": "django__django-12708", "model_patch": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 61f88401ab..1cec48fc77 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -407,6 +407,22 @@ class BaseDatabaseSchemaEditor:\n             model, columns, exclude=meta_constraint_names | meta_index_names,\n             **constraint_kwargs\n         )\n+        \n+        # If we're dropping an index constraint and found multiple constraints,\n+        # filter out unique constraints to avoid conflicts with unique_together.\n+        # This handles the case where the same fields have both index_together\n+        # and unique_together, and we only want to drop the index constraint.\n+        if constraint_kwargs.get('index') and len(constraint_names) > 1:\n+            unique_constraint_names = self._constraint_names(\n+                model, columns, exclude=meta_constraint_names | meta_index_names,\n+                unique=True\n+            )\n+            # Filter out any constraint names that correspond to unique constraints\n+            constraint_names = [\n+                name for name in constraint_names \n+                if name not in unique_constraint_names\n+            ]\n+        \n         if len(constraint_names) != 1:\n             raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n                 len(constraint_names),\n"}
{"model_name_or_path": "ase_4", "instance_id": "django__django-12708", "model_patch": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 61f88401ab..9edf3a4944 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -407,6 +407,25 @@ class BaseDatabaseSchemaEditor:\n             model, columns, exclude=meta_constraint_names | meta_index_names,\n             **constraint_kwargs\n         )\n+        if len(constraint_names) != 1:\n+            # If we're looking for an index constraint but found multiple constraints,\n+            # filter out unique constraints to avoid conflicts\n+            if constraint_kwargs.get('index', False) and len(constraint_names) > 1:\n+                unique_constraint_names = self._constraint_names(\n+                    model, columns, exclude=meta_constraint_names | meta_index_names,\n+                    unique=True\n+                )\n+                constraint_names = [name for name in constraint_names if name not in unique_constraint_names]\n+            \n+            # If we're looking for a unique constraint but found multiple constraints,\n+            # filter out index constraints to avoid conflicts  \n+            elif constraint_kwargs.get('unique', False) and len(constraint_names) > 1:\n+                index_constraint_names = self._constraint_names(\n+                    model, columns, exclude=meta_constraint_names | meta_index_names,\n+                    index=True\n+                )\n+                constraint_names = [name for name in constraint_names if name not in index_constraint_names]\n+        \n         if len(constraint_names) != 1:\n             raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n                 len(constraint_names),\n"}
{"model_name_or_path": "ase_5", "instance_id": "django__django-12708", "model_patch": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 61f88401ab..ef180196df 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -407,6 +407,27 @@ class BaseDatabaseSchemaEditor:\n             model, columns, exclude=meta_constraint_names | meta_index_names,\n             **constraint_kwargs\n         )\n+        \n+        # If more than one constraint is returned (e.g. an index plus a unique index),\n+        # drop the opposite type so we only delete the intended one.\n+        if len(constraint_names) > 1:\n+            # Determine the \"other\" flag (the opposite of what we're deleting)\n+            if constraint_kwargs.get('unique'):\n+                other_flag = {'index': True}\n+            elif constraint_kwargs.get('index'):\n+                other_flag = {'unique': True}\n+            else:\n+                other_flag = {}\n+            if other_flag:\n+                # Subtract out any constraints of the other type\n+                other_names = set(self._constraint_names(\n+                    model, columns,\n+                    exclude=meta_constraint_names | meta_index_names,\n+                    **other_flag\n+                ))\n+                constraint_names = [name for name in constraint_names if name not in other_names]\n+\n+        # We must end up with exactly one constraint name to delete\n         if len(constraint_names) != 1:\n             raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n                 len(constraint_names),\n"}
{"model_name_or_path": "ase_6", "instance_id": "django__django-12708", "model_patch": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 61f88401ab..721b6e2791 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -407,12 +407,36 @@ class BaseDatabaseSchemaEditor:\n             model, columns, exclude=meta_constraint_names | meta_index_names,\n             **constraint_kwargs\n         )\n-        if len(constraint_names) != 1:\n-            raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n-                len(constraint_names),\n-                model._meta.db_table,\n-                \", \".join(columns),\n+        \n+        # If we found multiple constraints, try to filter by the specific type we need\n+        if len(constraint_names) > 1:\n+            # Get all unique constraints and all index constraints for these columns\n+            unique_constraint_names = set(self._constraint_names(\n+                model, columns, exclude=meta_constraint_names | meta_index_names,\n+                unique=True\n             ))\n+            index_constraint_names = set(self._constraint_names(\n+                model, columns, exclude=meta_constraint_names | meta_index_names,\n+                index=True\n+            ))\n+            \n+            if constraint_kwargs.get('unique'):\n+                # For unique_together deletion, only consider unique constraints\n+                constraint_names = list(set(constraint_names) & unique_constraint_names)\n+            elif constraint_kwargs.get('index'):\n+                # For index_together deletion, only consider index constraints that are not unique\n+                constraint_names = list(set(constraint_names) & (index_constraint_names - unique_constraint_names))\n+        \n+        if len(constraint_names) != 1:\n+            raise ValueError(\n+                \"Found wrong number (%s) of constraints for %s(%s). \"\n+                \"Expected exactly 1 constraint, but found: %s\" % (\n+                    len(constraint_names),\n+                    model._meta.db_table,\n+                    \", \".join(columns),\n+                    constraint_names if constraint_names else \"none\"\n+                )\n+            )\n         self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n \n     def alter_db_table(self, model, old_db_table, new_db_table):\n"}
{"model_name_or_path": "ase_7", "instance_id": "django__django-12708", "model_patch": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 61f88401ab..daadd3129a 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -407,6 +407,24 @@ class BaseDatabaseSchemaEditor:\n             model, columns, exclude=meta_constraint_names | meta_index_names,\n             **constraint_kwargs\n         )\n+        \n+        # Handle the case where both unique and index constraints exist on the same fields\n+        if len(constraint_names) > 1:\n+            # If we're specifically looking for unique constraints, exclude index-only constraints\n+            if constraint_kwargs.get('unique', False) and not constraint_kwargs.get('index', False):\n+                index_constraint_names = self._constraint_names(\n+                    model, columns, exclude=meta_constraint_names | meta_index_names,\n+                    index=True, unique=False\n+                )\n+                constraint_names = [name for name in constraint_names if name not in index_constraint_names]\n+            # If we're specifically looking for index constraints, exclude unique-only constraints\n+            elif constraint_kwargs.get('index', False) and not constraint_kwargs.get('unique', False):\n+                unique_constraint_names = self._constraint_names(\n+                    model, columns, exclude=meta_constraint_names | meta_index_names,\n+                    unique=True, index=False\n+                )\n+                constraint_names = [name for name in constraint_names if name not in unique_constraint_names]\n+        \n         if len(constraint_names) != 1:\n             raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n                 len(constraint_names),\n"}
{"model_name_or_path": "ase_8", "instance_id": "django__django-12708", "model_patch": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 61f88401ab..81f12e7537 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -400,6 +400,13 @@ class BaseDatabaseSchemaEditor:\n             self.execute(self._create_index_sql(model, fields, suffix=\"_idx\"))\n \n     def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n+        \"\"\"\n+        Delete a composed index (unique_together or index_together constraint).\n+        \n+        Special case: if both a unique_together and index_together exist on \n+        the same columns, we filter out the \"other\" constraint type so we only \n+        drop one backend constraint at a time.\n+        \"\"\"\n         meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n         meta_index_names = {constraint.name for constraint in model._meta.indexes}\n         columns = [model._meta.get_field(field).column for field in fields]\n@@ -407,12 +414,42 @@ class BaseDatabaseSchemaEditor:\n             model, columns, exclude=meta_constraint_names | meta_index_names,\n             **constraint_kwargs\n         )\n+        \n+        # Handle overlapping unique_together and index_together on same fields\n+        if len(constraint_names) > 1:\n+            # If we're looking for an index constraint, filter out unique constraints\n+            if constraint_kwargs.get('index', False) and not constraint_kwargs.get('unique', False):\n+                unique_constraint_names = self._constraint_names(\n+                    model, columns, exclude=meta_constraint_names | meta_index_names,\n+                    index=False, unique=True\n+                )\n+                constraint_names = [name for name in constraint_names if name not in unique_constraint_names]\n+            \n+            # If we're looking for a unique constraint, filter out non-unique index constraints  \n+            elif constraint_kwargs.get('unique', False) and not constraint_kwargs.get('index', False):\n+                index_constraint_names = self._constraint_names(\n+                    model, columns, exclude=meta_constraint_names | meta_index_names,\n+                    index=True, unique=False\n+                )\n+                constraint_names = [name for name in constraint_names if name not in index_constraint_names]\n+        \n+        # If we're dropping an index but none exists (e.g., already dropped with unique), skip silently\n+        if (constraint_kwargs.get('index', False) and not constraint_kwargs.get('unique', False) \n+                and not constraint_names):\n+            return\n+            \n         if len(constraint_names) != 1:\n-            raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n-                len(constraint_names),\n-                model._meta.db_table,\n-                \", \".join(columns),\n-            ))\n+            constraint_type = 'index' if constraint_kwargs.get('index', False) else 'unique'\n+            names_str = ', '.join(constraint_names) if constraint_names else 'none'\n+            raise ValueError(\n+                \"Found wrong number (%s) of %s constraints for %s(%s): %s\" % (\n+                    len(constraint_names),\n+                    constraint_type,\n+                    model._meta.db_table,\n+                    \", \".join(columns),\n+                    names_str,\n+                )\n+            )\n         self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n \n     def alter_db_table(self, model, old_db_table, new_db_table):\n"}
{"model_name_or_path": "ase_9", "instance_id": "django__django-12708", "model_patch": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 61f88401ab..a9a6c4bf23 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -403,10 +403,28 @@ class BaseDatabaseSchemaEditor:\n         meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n         meta_index_names = {constraint.name for constraint in model._meta.indexes}\n         columns = [model._meta.get_field(field).column for field in fields]\n-        constraint_names = self._constraint_names(\n-            model, columns, exclude=meta_constraint_names | meta_index_names,\n-            **constraint_kwargs\n-        )\n+        \n+        # Be more specific about constraint type to avoid conflicts between\n+        # unique_together and index_together on the same fields\n+        if constraint_kwargs.get('unique'):\n+            # When deleting unique constraints, explicitly look for unique=True\n+            constraint_names = self._constraint_names(\n+                model, columns, exclude=meta_constraint_names | meta_index_names,\n+                unique=True\n+            )\n+        elif constraint_kwargs.get('index'):\n+            # When deleting index constraints, look for index=True and exclude unique ones\n+            constraint_names = self._constraint_names(\n+                model, columns, exclude=meta_constraint_names | meta_index_names,\n+                index=True, unique=False\n+            )\n+        else:\n+            # Fallback to original behavior for other constraint types\n+            constraint_names = self._constraint_names(\n+                model, columns, exclude=meta_constraint_names | meta_index_names,\n+                **constraint_kwargs\n+            )\n+        \n         if len(constraint_names) != 1:\n             raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n                 len(constraint_names),\n"}
{"model_name_or_path": "ase_10", "instance_id": "django__django-12708", "model_patch": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 61f88401ab..16604fb026 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -407,13 +407,70 @@ class BaseDatabaseSchemaEditor:\n             model, columns, exclude=meta_constraint_names | meta_index_names,\n             **constraint_kwargs\n         )\n-        if len(constraint_names) != 1:\n-            raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n+        \n+        # Fast path: exactly one constraint found\n+        if len(constraint_names) == 1:\n+            self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n+            return\n+        \n+        # No constraints found: this might be expected (already dropped)\n+        if len(constraint_names) == 0:\n+            import warnings\n+            constraint_type = \"unique\" if constraint_kwargs.get('unique') else \"index\"\n+            warnings.warn(\n+                \"No matching %s constraint found on %s(%s); skipping drop.\" % (\n+                    constraint_type,\n+                    model._meta.db_table,\n+                    \", \".join(columns)\n+                ),\n+                RuntimeWarning\n+            )\n+            return\n+        \n+        # Multiple constraints found: try to disambiguate by being more specific\n+        if len(constraint_names) > 1:\n+            # When both unique and index constraints exist on the same fields,\n+            # we need to be more specific about which type we're targeting\n+            if constraint_kwargs.get('unique'):\n+                # For unique constraints, get only unique constraints\n+                specific_names = self._constraint_names(\n+                    model, columns, unique=True,\n+                    exclude=meta_constraint_names | meta_index_names\n+                )\n+            elif constraint_kwargs.get('index'):\n+                # For index constraints, get all index constraints then exclude unique ones\n+                all_index_names = set(self._constraint_names(\n+                    model, columns, index=True,\n+                    exclude=meta_constraint_names | meta_index_names\n+                ))\n+                unique_names = set(self._constraint_names(\n+                    model, columns, unique=True,\n+                    exclude=meta_constraint_names | meta_index_names\n+                ))\n+                # Only keep index constraints that are not unique constraints\n+                specific_names = list(all_index_names - unique_names)\n+            else:\n+                specific_names = constraint_names\n+            \n+            # If we successfully narrowed it down to exactly one, use it\n+            if len(specific_names) == 1:\n+                self.execute(self._delete_constraint_sql(sql, model, specific_names[0]))\n+                return\n+            \n+            constraint_names = specific_names\n+        \n+        # Still ambiguous or no matches after filtering\n+        constraint_type = \"unique\" if constraint_kwargs.get('unique') else \"index\"\n+        raise ValueError(\n+            \"Found wrong number (%s) of %s constraints for %s(%s). \"\n+            \"Expected exactly 1, but found: %s\" % (\n                 len(constraint_names),\n+                constraint_type,\n                 model._meta.db_table,\n                 \", \".join(columns),\n-            ))\n-        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n+                constraint_names if constraint_names else \"none\"\n+            )\n+        )\n \n     def alter_db_table(self, model, old_db_table, new_db_table):\n         \"\"\"Rename the table a model points to.\"\"\"\n"}
{"model_name_or_path": "ase_11", "instance_id": "django__django-12708", "model_patch": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 61f88401ab..a9c21902d3 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -407,12 +407,44 @@ class BaseDatabaseSchemaEditor:\n             model, columns, exclude=meta_constraint_names | meta_index_names,\n             **constraint_kwargs\n         )\n-        if len(constraint_names) != 1:\n-            raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n-                len(constraint_names),\n-                model._meta.db_table,\n-                \", \".join(columns),\n-            ))\n+        \n+        # Handle the case where both unique_together and index_together exist on same fields\n+        if len(constraint_names) > 1:\n+            # If we're looking for index constraints, filter out unique constraints\n+            if constraint_kwargs.get('index', False) and not constraint_kwargs.get('unique', False):\n+                unique_constraint_names = self._constraint_names(\n+                    model, columns, exclude=meta_constraint_names | meta_index_names,\n+                    unique=True\n+                )\n+                constraint_names = [name for name in constraint_names if name not in unique_constraint_names]\n+            \n+            # If we're looking for unique constraints, filter out non-unique index constraints\n+            elif constraint_kwargs.get('unique', False):\n+                index_only_constraint_names = self._constraint_names(\n+                    model, columns, exclude=meta_constraint_names | meta_index_names,\n+                    index=True\n+                )\n+                # Get constraints that are index-only (not unique indexes)\n+                unique_constraint_names = self._constraint_names(\n+                    model, columns, exclude=meta_constraint_names | meta_index_names,\n+                    unique=True\n+                )\n+                pure_index_names = [name for name in index_only_constraint_names if name not in unique_constraint_names]\n+                constraint_names = [name for name in constraint_names if name not in pure_index_names]\n+        \n+        if len(constraint_names) == 0:\n+            # No constraints found - this might be valid in some migration scenarios\n+            return\n+        elif len(constraint_names) != 1:\n+            raise ValueError(\n+                \"Found wrong number (%s) of constraints for %s(%s). \"\n+                \"This may indicate conflicting unique_together and index_together \"\n+                \"definitions on the same fields.\" % (\n+                    len(constraint_names),\n+                    model._meta.db_table,\n+                    \", \".join(columns),\n+                )\n+            )\n         self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n \n     def alter_db_table(self, model, old_db_table, new_db_table):\n"}
{"model_name_or_path": "ase_12", "instance_id": "django__django-12708", "model_patch": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 61f88401ab..0b71f3616e 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -407,6 +407,17 @@ class BaseDatabaseSchemaEditor:\n             model, columns, exclude=meta_constraint_names | meta_index_names,\n             **constraint_kwargs\n         )\n+        \n+        # If we're looking for index constraints and found multiple constraints,\n+        # filter out unique constraints to avoid conflicts with unique_together\n+        if constraint_kwargs.get('index') and len(constraint_names) > 1:\n+            # Get unique constraint names to exclude them\n+            unique_constraint_names = self._constraint_names(\n+                model, columns, exclude=meta_constraint_names | meta_index_names,\n+                unique=True\n+            )\n+            constraint_names = constraint_names - unique_constraint_names\n+        \n         if len(constraint_names) != 1:\n             raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n                 len(constraint_names),\n"}
{"model_name_or_path": "ase_13", "instance_id": "django__django-12708", "model_patch": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 61f88401ab..4357215a91 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -408,11 +408,35 @@ class BaseDatabaseSchemaEditor:\n             **constraint_kwargs\n         )\n         if len(constraint_names) != 1:\n-            raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n-                len(constraint_names),\n-                model._meta.db_table,\n-                \", \".join(columns),\n-            ))\n+            # If we found multiple constraints, try to be more specific about the type\n+            if len(constraint_names) > 1:\n+                # Filter constraint names to only include the specific type we're looking for\n+                if constraint_kwargs.get('unique'):\n+                    # For unique constraints, exclude index-only constraints\n+                    filtered_names = []\n+                    for name in constraint_names:\n+                        # Check if this constraint is actually unique (not just an index)\n+                        unique_constraints = self._constraint_names(model, columns, unique=True, exclude=meta_constraint_names | meta_index_names)\n+                        if name in unique_constraints:\n+                            filtered_names.append(name)\n+                    constraint_names = filtered_names\n+                elif constraint_kwargs.get('index'):\n+                    # For index constraints, exclude unique constraints\n+                    filtered_names = []\n+                    for name in constraint_names:\n+                        # Check if this constraint is actually an index (not unique)\n+                        unique_constraints = self._constraint_names(model, columns, unique=True, exclude=meta_constraint_names | meta_index_names)\n+                        if name not in unique_constraints:\n+                            filtered_names.append(name)\n+                    constraint_names = filtered_names\n+            \n+            # If we still don't have exactly one constraint, raise the error\n+            if len(constraint_names) != 1:\n+                raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n+                    len(constraint_names),\n+                    model._meta.db_table,\n+                    \", \".join(columns),\n+                ))\n         self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n \n     def alter_db_table(self, model, old_db_table, new_db_table):\n"}
{"model_name_or_path": "ase_14", "instance_id": "django__django-12708", "model_patch": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 61f88401ab..28bdf31f2a 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -403,10 +403,36 @@ class BaseDatabaseSchemaEditor:\n         meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n         meta_index_names = {constraint.name for constraint in model._meta.indexes}\n         columns = [model._meta.get_field(field).column for field in fields]\n+        \n+        # Get constraints matching the specific type we want to delete\n         constraint_names = self._constraint_names(\n             model, columns, exclude=meta_constraint_names | meta_index_names,\n             **constraint_kwargs\n         )\n+        \n+        # If we found multiple constraints, we might have both unique and index\n+        # constraints on the same fields. Filter to get only the type we want.\n+        if len(constraint_names) > 1:\n+            if constraint_kwargs.get('unique'):\n+                # When deleting unique constraints, exclude index-only constraints\n+                index_only_names = self._constraint_names(\n+                    model, columns, exclude=meta_constraint_names | meta_index_names,\n+                    index=True\n+                )\n+                # Get unique constraint names by excluding index-only ones\n+                unique_names = self._constraint_names(\n+                    model, columns, exclude=meta_constraint_names | meta_index_names,\n+                    unique=True\n+                )\n+                constraint_names = unique_names\n+            elif constraint_kwargs.get('index'):\n+                # When deleting index constraints, exclude unique constraints\n+                unique_names = self._constraint_names(\n+                    model, columns, exclude=meta_constraint_names | meta_index_names,\n+                    unique=True\n+                )\n+                constraint_names = constraint_names - unique_names\n+        \n         if len(constraint_names) != 1:\n             raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n                 len(constraint_names),\n"}
{"model_name_or_path": "ase_15", "instance_id": "django__django-12708", "model_patch": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 61f88401ab..68c5e08c63 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -393,7 +393,7 @@ class BaseDatabaseSchemaEditor:\n         news = {tuple(fields) for fields in new_index_together}\n         # Deleted indexes\n         for fields in olds.difference(news):\n-            self._delete_composed_index(model, fields, {'index': True}, self.sql_delete_index)\n+            self._delete_composed_index(model, fields, {'index': True, 'unique': False}, self.sql_delete_index)\n         # Created indexes\n         for field_names in news.difference(olds):\n             fields = [model._meta.get_field(field) for field in field_names]\n@@ -407,6 +407,18 @@ class BaseDatabaseSchemaEditor:\n             model, columns, exclude=meta_constraint_names | meta_index_names,\n             **constraint_kwargs\n         )\n+        \n+        # If we're looking for index constraints and found multiple constraints,\n+        # filter out unique constraints to avoid conflicts with unique_together\n+        if constraint_kwargs.get('index') and len(constraint_names) > 1:\n+            # Get unique constraint names to exclude them\n+            unique_constraint_names = self._constraint_names(\n+                model, columns, exclude=meta_constraint_names | meta_index_names,\n+                unique=True\n+            )\n+            # Filter using list comprehension to avoid type errors\n+            constraint_names = [name for name in constraint_names if name not in unique_constraint_names]\n+        \n         if len(constraint_names) != 1:\n             raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n                 len(constraint_names),\n"}
{"model_name_or_path": "ase_16", "instance_id": "django__django-12708", "model_patch": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 61f88401ab..1a1e975030 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -403,17 +403,47 @@ class BaseDatabaseSchemaEditor:\n         meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n         meta_index_names = {constraint.name for constraint in model._meta.indexes}\n         columns = [model._meta.get_field(field).column for field in fields]\n-        constraint_names = self._constraint_names(\n-            model, columns, exclude=meta_constraint_names | meta_index_names,\n-            **constraint_kwargs\n-        )\n-        if len(constraint_names) != 1:\n-            raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n-                len(constraint_names),\n-                model._meta.db_table,\n-                \", \".join(columns),\n-            ))\n-        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n+        \n+        # Get all constraints from the database\n+        table_name = model._meta.db_table\n+        all_constraints = self.connection.introspection.get_constraints(self.connection.cursor(), table_name)\n+        \n+        # Filter constraints that match our columns and type requirements\n+        matched_constraints = []\n+        for constraint_name, constraint_info in all_constraints.items():\n+            # Skip constraints that are defined in model meta (they're handled elsewhere)\n+            if constraint_name in meta_constraint_names or constraint_name in meta_index_names:\n+                continue\n+                \n+            # Check if columns match\n+            constraint_columns = constraint_info.get('columns', [])\n+            if sorted(constraint_columns) != sorted(columns):\n+                continue\n+                \n+            # Check if constraint type matches what we're looking for\n+            matches_type = True\n+            for key, expected_value in constraint_kwargs.items():\n+                constraint_value = constraint_info.get(key, False)\n+                if constraint_value != expected_value:\n+                    matches_type = False\n+                    break\n+                    \n+            if matches_type:\n+                matched_constraints.append(constraint_name)\n+        \n+        if len(matched_constraints) != 1:\n+            constraint_type = \"unique\" if constraint_kwargs.get('unique') else \"index\" if constraint_kwargs.get('index') else \"unknown\"\n+            raise ValueError(\n+                \"Found wrong number (%s) of %s constraints for %s(%s). Expected exactly 1, found: %s\" % (\n+                    len(matched_constraints),\n+                    constraint_type,\n+                    model._meta.db_table,\n+                    \", \".join(columns),\n+                    \", \".join(sorted(matched_constraints)) if matched_constraints else \"none\"\n+                )\n+            )\n+        \n+        self.execute(self._delete_constraint_sql(sql, model, matched_constraints[0]))\n \n     def alter_db_table(self, model, old_db_table, new_db_table):\n         \"\"\"Rename the table a model points to.\"\"\"\n"}
{"model_name_or_path": "ase_17", "instance_id": "django__django-12708", "model_patch": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 61f88401ab..bbffab32aa 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -399,7 +399,38 @@ class BaseDatabaseSchemaEditor:\n             fields = [model._meta.get_field(field) for field in field_names]\n             self.execute(self._create_index_sql(model, fields, suffix=\"_idx\"))\n \n+    def _pick_single_constraint(self, model, columns, exclude, **constraint_kwargs):\n+        \"\"\"\n+        Return exactly one constraint name matching the given criteria.\n+        Raises ValueError if zero or more than one constraint is found.\n+        \n+        This helper handles cases where multiple constraint types exist on the same\n+        columns (e.g., both unique_together and index_together) by filtering to\n+        the specific type requested.\n+        \"\"\"\n+        constraint_names = self._constraint_names(\n+            model, columns, exclude=exclude, **constraint_kwargs\n+        )\n+        if len(constraint_names) != 1:\n+            constraint_type = 'unique' if constraint_kwargs.get('unique') else 'index'\n+            raise ValueError(\n+                \"Expected exactly one %s constraint on %s(%s), got %s: %s\" % (\n+                    constraint_type,\n+                    model._meta.db_table,\n+                    \", \".join(columns),\n+                    len(constraint_names),\n+                    \", \".join(sorted(constraint_names)) if constraint_names else \"none\"\n+                )\n+            )\n+        return constraint_names[0]\n+\n     def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n+        \"\"\"\n+        Delete a composed index (unique_together or index_together).\n+        \n+        Special handling when both unique_together and index_together exist on the same columns:\n+        introspection may return both a UNIQUE and an INDEX constraint; re-query by type to disambiguate.\n+        \"\"\"\n         meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n         meta_index_names = {constraint.name for constraint in model._meta.indexes}\n         columns = [model._meta.get_field(field).column for field in fields]\n@@ -407,13 +438,18 @@ class BaseDatabaseSchemaEditor:\n             model, columns, exclude=meta_constraint_names | meta_index_names,\n             **constraint_kwargs\n         )\n+        \n         if len(constraint_names) != 1:\n-            raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n-                len(constraint_names),\n-                model._meta.db_table,\n-                \", \".join(columns),\n-            ))\n-        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n+            # When multiple constraints exist (e.g., both unique and index on same columns),\n+            # use the helper to pick exactly the type we want to delete\n+            constraint_name = self._pick_single_constraint(\n+                model, columns, exclude=meta_constraint_names | meta_index_names,\n+                **constraint_kwargs\n+            )\n+        else:\n+            constraint_name = constraint_names[0]\n+            \n+        self.execute(self._delete_constraint_sql(sql, model, constraint_name))\n \n     def alter_db_table(self, model, old_db_table, new_db_table):\n         \"\"\"Rename the table a model points to.\"\"\"\n"}
{"model_name_or_path": "ase_18", "instance_id": "django__django-12708", "model_patch": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 61f88401ab..f6b81a23a0 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -407,6 +407,18 @@ class BaseDatabaseSchemaEditor:\n             model, columns, exclude=meta_constraint_names | meta_index_names,\n             **constraint_kwargs\n         )\n+        \n+        # If dropping an index and multiple constraints found, filter out unique-backed indexes\n+        if constraint_kwargs.get('index') and len(constraint_names) > 1:\n+            # Find unique constraint names on the same columns\n+            unique_constraint_names = set(self._constraint_names(\n+                model, columns,\n+                unique=True,\n+                exclude=meta_constraint_names | meta_index_names,\n+            ))\n+            # Filter out any index that backs a unique constraint\n+            constraint_names = [name for name in constraint_names if name not in unique_constraint_names]\n+        \n         if len(constraint_names) != 1:\n             raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n                 len(constraint_names),\n"}
{"model_name_or_path": "ase_19", "instance_id": "django__django-12708", "model_patch": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 61f88401ab..69a9fa363e 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -403,16 +403,56 @@ class BaseDatabaseSchemaEditor:\n         meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n         meta_index_names = {constraint.name for constraint in model._meta.indexes}\n         columns = [model._meta.get_field(field).column for field in fields]\n-        constraint_names = self._constraint_names(\n+        \n+        # Get all potential constraints first\n+        all_constraint_names = self._constraint_names(\n             model, columns, exclude=meta_constraint_names | meta_index_names,\n             **constraint_kwargs\n         )\n+        \n+        # If we're looking for a specific type and found multiple constraints,\n+        # try to filter them based on the constraint type\n+        constraint_names = all_constraint_names\n+        if len(all_constraint_names) > 1:\n+            if constraint_kwargs.get('unique'):\n+                # For unique_together deletion, prefer unique constraints over index-only constraints\n+                unique_only_names = self._constraint_names(\n+                    model, columns, exclude=meta_constraint_names | meta_index_names,\n+                    unique=True\n+                )\n+                if unique_only_names:\n+                    constraint_names = unique_only_names\n+            elif constraint_kwargs.get('index'):\n+                # For index_together deletion, prefer index constraints that are NOT unique constraints\n+                unique_constraint_names = self._constraint_names(\n+                    model, columns, exclude=meta_constraint_names | meta_index_names,\n+                    unique=True\n+                )\n+                # Filter out unique constraints, keeping only non-unique index constraints\n+                index_only_names = [name for name in all_constraint_names if name not in unique_constraint_names]\n+                if index_only_names:\n+                    constraint_names = index_only_names\n+        \n         if len(constraint_names) != 1:\n-            raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n-                len(constraint_names),\n-                model._meta.db_table,\n-                \", \".join(columns),\n-            ))\n+            constraint_type = \"unique\" if constraint_kwargs.get('unique') else \"index\"\n+            if len(constraint_names) == 0:\n+                # No constraints found - this might happen if the constraint was already deleted\n+                # or if we filtered out all constraints. In this case, we can safely return.\n+                return\n+            else:\n+                # Multiple constraints found - provide a more helpful error message\n+                raise ValueError(\n+                    \"Found wrong number (%s) of %s constraints for %s(%s). \"\n+                    \"Found constraints: %s. This may indicate both unique_together and \"\n+                    \"index_together exist on the same fields.\" % (\n+                        len(constraint_names),\n+                        constraint_type,\n+                        model._meta.db_table,\n+                        \", \".join(columns),\n+                        \", \".join(sorted(constraint_names))\n+                    )\n+                )\n+        \n         self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n \n     def alter_db_table(self, model, old_db_table, new_db_table):\n"}
{"model_name_or_path": "ase_20", "instance_id": "django__django-12708", "model_patch": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 61f88401ab..bc9dcccc39 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -408,11 +408,35 @@ class BaseDatabaseSchemaEditor:\n             **constraint_kwargs\n         )\n         if len(constraint_names) != 1:\n-            raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n-                len(constraint_names),\n-                model._meta.db_table,\n-                \", \".join(columns),\n-            ))\n+            # Handle the case where both unique_together and index_together exist\n+            # on the same fields by being more specific about constraint types\n+            if len(constraint_names) > 1:\n+                # If we're looking for a unique constraint, exclude pure indexes\n+                if constraint_kwargs.get('unique'):\n+                    # Get constraints that are unique but exclude those that are only indexes\n+                    index_only_names = self._constraint_names(\n+                        model, columns, exclude=meta_constraint_names | meta_index_names,\n+                        index=True, unique=False\n+                    )\n+                    constraint_names = [name for name in constraint_names if name not in index_only_names]\n+                # If we're looking for an index constraint, exclude unique constraints\n+                elif constraint_kwargs.get('index'):\n+                    # Get constraints that are unique to exclude them\n+                    unique_names = self._constraint_names(\n+                        model, columns, exclude=meta_constraint_names | meta_index_names,\n+                        unique=True\n+                    )\n+                    constraint_names = [name for name in constraint_names if name not in unique_names]\n+            \n+            # If we still don't have exactly one constraint, raise an error\n+            if len(constraint_names) != 1:\n+                constraint_type = 'unique' if constraint_kwargs.get('unique') else 'index'\n+                raise ValueError(\"Found wrong number (%s) of %s constraints for %s(%s)\" % (\n+                    len(constraint_names),\n+                    constraint_type,\n+                    model._meta.db_table,\n+                    \", \".join(columns),\n+                ))\n         self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n \n     def alter_db_table(self, model, old_db_table, new_db_table):\n"}
{"model_name_or_path": "ase_21", "instance_id": "django__django-12708", "model_patch": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 61f88401ab..43fdece700 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -400,20 +400,70 @@ class BaseDatabaseSchemaEditor:\n             self.execute(self._create_index_sql(model, fields, suffix=\"_idx\"))\n \n     def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n+        \"\"\"\n+        Delete a composed index (unique_together or index_together).\n+        \n+        Special handling: When both unique_together and index_together exist on\n+        the same fields, we need to filter out the conflicting constraint type\n+        to avoid ambiguity during deletion.\n+        \"\"\"\n         meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n         meta_index_names = {constraint.name for constraint in model._meta.indexes}\n         columns = [model._meta.get_field(field).column for field in fields]\n+        exclude_names = meta_constraint_names | meta_index_names\n+        \n+        # Get initial constraint candidates\n         constraint_names = self._constraint_names(\n-            model, columns, exclude=meta_constraint_names | meta_index_names,\n-            **constraint_kwargs\n+            model, columns, exclude=exclude_names, **constraint_kwargs\n         )\n-        if len(constraint_names) != 1:\n-            raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n-                len(constraint_names),\n-                model._meta.db_table,\n-                \", \".join(columns),\n-            ))\n-        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n+        \n+        # Handle index deletion with potential unique constraint conflicts\n+        if constraint_kwargs.get('index', False):\n+            if not constraint_names:\n+                # No index found to delete - this is OK for idempotent migrations\n+                return\n+            \n+            if len(constraint_names) > 1:\n+                # Filter out unique constraints to avoid conflicts when both\n+                # unique_together and index_together exist on same fields\n+                unique_constraint_names = self._constraint_names(\n+                    model, columns, exclude=exclude_names, unique=True\n+                )\n+                constraint_names = [name for name in constraint_names \n+                                  if name not in unique_constraint_names]\n+        \n+        # Handle unique deletion - these typically don't have conflicts\n+        elif constraint_kwargs.get('unique', False):\n+            if len(constraint_names) > 1:\n+                # Filter out pure index constraints to avoid conflicts\n+                index_constraint_names = self._constraint_names(\n+                    model, columns, exclude=exclude_names, index=True, unique=False\n+                )\n+                constraint_names = [name for name in constraint_names \n+                                  if name not in index_constraint_names]\n+        \n+        # Final validation\n+        if len(constraint_names) == 0:\n+            if constraint_kwargs.get('unique', False):\n+                # For unique constraints, not finding any is an error\n+                raise ValueError(\"No unique constraint found for %s(%s)\" % (\n+                    model._meta.db_table, \", \".join(columns)\n+                ))\n+            # For index constraints, we already returned early above\n+        elif len(constraint_names) != 1:\n+            constraint_type = 'index' if constraint_kwargs.get('index', False) else 'unique'\n+            raise ValueError(\n+                \"Found wrong number (%s) of %s constraints for %s(%s). \"\n+                \"Constraints found: %s\" % (\n+                    len(constraint_names),\n+                    constraint_type,\n+                    model._meta.db_table,\n+                    \", \".join(columns),\n+                    \", \".join(constraint_names)\n+                )\n+            )\n+        else:\n+            self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n \n     def alter_db_table(self, model, old_db_table, new_db_table):\n         \"\"\"Rename the table a model points to.\"\"\"\n"}
{"model_name_or_path": "ase_22", "instance_id": "django__django-12708", "model_patch": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 61f88401ab..df8b589c9f 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -408,11 +408,56 @@ class BaseDatabaseSchemaEditor:\n             **constraint_kwargs\n         )\n         if len(constraint_names) != 1:\n-            raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n-                len(constraint_names),\n-                model._meta.db_table,\n-                \", \".join(columns),\n-            ))\n+            # If we have multiple constraints, try to be more specific\n+            # This handles the case where both unique_together and index_together\n+            # exist on the same fields\n+            if len(constraint_names) > 1:\n+                # Get all constraint names without filtering by type\n+                all_constraint_names = self._constraint_names(\n+                    model, columns, exclude=meta_constraint_names | meta_index_names\n+                )\n+                # Filter by the specific constraint type we want to delete\n+                if 'unique' in constraint_kwargs and constraint_kwargs['unique']:\n+                    # For unique constraints, get only unique constraint names\n+                    unique_constraint_names = self._constraint_names(\n+                        model, columns, exclude=meta_constraint_names | meta_index_names,\n+                        unique=True\n+                    )\n+                    # Remove any that are also indexes to get pure unique constraints\n+                    index_constraint_names = self._constraint_names(\n+                        model, columns, exclude=meta_constraint_names | meta_index_names,\n+                        index=True\n+                    )\n+                    constraint_names = [name for name in unique_constraint_names \n+                                      if name not in index_constraint_names or \n+                                      not self._constraint_names(model, columns, exclude=meta_constraint_names | meta_index_names, index=True, unique=False)]\n+                elif 'index' in constraint_kwargs and constraint_kwargs['index']:\n+                    # For index constraints, get only index constraint names  \n+                    index_constraint_names = self._constraint_names(\n+                        model, columns, exclude=meta_constraint_names | meta_index_names,\n+                        index=True\n+                    )\n+                    # Remove any that are also unique constraints to get pure index constraints\n+                    unique_constraint_names = self._constraint_names(\n+                        model, columns, exclude=meta_constraint_names | meta_index_names,\n+                        unique=True\n+                    )\n+                    constraint_names = [name for name in index_constraint_names \n+                                      if name not in unique_constraint_names]\n+                \n+                # If we still don't have exactly one, fall back to original error\n+                if len(constraint_names) != 1:\n+                    raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n+                        len(constraint_names),\n+                        model._meta.db_table,\n+                        \", \".join(columns),\n+                    ))\n+            else:\n+                raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n+                    len(constraint_names),\n+                    model._meta.db_table,\n+                    \", \".join(columns),\n+                ))\n         self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n \n     def alter_db_table(self, model, old_db_table, new_db_table):\n"}
{"model_name_or_path": "ase_23", "instance_id": "django__django-12708", "model_patch": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 61f88401ab..213470e51d 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -407,6 +407,30 @@ class BaseDatabaseSchemaEditor:\n             model, columns, exclude=meta_constraint_names | meta_index_names,\n             **constraint_kwargs\n         )\n+        \n+        # Handle the case where both unique and index constraints exist on same fields\n+        if len(constraint_names) > 1:\n+            # Get detailed constraint information to filter precisely\n+            all_constraint_info = self.connection.introspection.get_constraints(\n+                self.connection.cursor(), model._meta.db_table\n+            )\n+            \n+            if constraint_kwargs.get('index', False) and not constraint_kwargs.get('unique', False):\n+                # When deleting index_together, keep only index constraints (exclude unique)\n+                constraint_names = {\n+                    name for name in constraint_names \n+                    if name in all_constraint_info and \n+                    all_constraint_info[name].get('index', False) and \n+                    not all_constraint_info[name].get('unique', False)\n+                }\n+            elif constraint_kwargs.get('unique', False) and not constraint_kwargs.get('index', False):\n+                # When deleting unique_together, keep only unique constraints (exclude index)\n+                constraint_names = {\n+                    name for name in constraint_names \n+                    if name in all_constraint_info and \n+                    all_constraint_info[name].get('unique', False)\n+                }\n+        \n         if len(constraint_names) != 1:\n             raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n                 len(constraint_names),\n"}
{"model_name_or_path": "ase_24", "instance_id": "django__django-12708", "model_patch": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 61f88401ab..0083b3cc04 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -377,7 +377,7 @@ class BaseDatabaseSchemaEditor:\n         news = {tuple(fields) for fields in new_unique_together}\n         # Deleted uniques\n         for fields in olds.difference(news):\n-            self._delete_composed_index(model, fields, {'unique': True}, self.sql_delete_unique)\n+            self._delete_composed_index(model, fields, {'unique': True, 'index': False}, self.sql_delete_unique)\n         # Created uniques\n         for fields in news.difference(olds):\n             columns = [model._meta.get_field(field).column for field in fields]\n@@ -393,7 +393,7 @@ class BaseDatabaseSchemaEditor:\n         news = {tuple(fields) for fields in new_index_together}\n         # Deleted indexes\n         for fields in olds.difference(news):\n-            self._delete_composed_index(model, fields, {'index': True}, self.sql_delete_index)\n+            self._delete_composed_index(model, fields, {'index': True, 'unique': False}, self.sql_delete_index)\n         # Created indexes\n         for field_names in news.difference(olds):\n             fields = [model._meta.get_field(field) for field in field_names]\n@@ -407,6 +407,9 @@ class BaseDatabaseSchemaEditor:\n             model, columns, exclude=meta_constraint_names | meta_index_names,\n             **constraint_kwargs\n         )\n+        if len(constraint_names) == 0:\n+            # No matching constraint found, nothing to delete\n+            return\n         if len(constraint_names) != 1:\n             raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n                 len(constraint_names),\n"}
{"model_name_or_path": "ase_25", "instance_id": "django__django-12708", "model_patch": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 61f88401ab..6bcba22285 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -407,13 +407,62 @@ class BaseDatabaseSchemaEditor:\n             model, columns, exclude=meta_constraint_names | meta_index_names,\n             **constraint_kwargs\n         )\n-        if len(constraint_names) != 1:\n+        \n+        # If we found exactly one constraint, use it directly\n+        if len(constraint_names) == 1:\n+            constraint_name = constraint_names[0]\n+        elif len(constraint_names) > 1:\n+            # Multiple constraints found - need to be more specific based on type\n+            if constraint_kwargs.get('unique'):\n+                # For unique constraints, get only unique constraints\n+                unique_constraints = self._constraint_names(\n+                    model, columns, exclude=meta_constraint_names | meta_index_names,\n+                    unique=True\n+                )\n+                if len(unique_constraints) == 1:\n+                    constraint_name = unique_constraints[0]\n+                else:\n+                    raise ValueError(\"Found wrong number (%s) of unique constraints for %s(%s)\" % (\n+                        len(unique_constraints),\n+                        model._meta.db_table,\n+                        \", \".join(columns),\n+                    ))\n+            elif constraint_kwargs.get('index'):\n+                # For index constraints, get indexes but exclude unique ones\n+                all_indexes = self._constraint_names(\n+                    model, columns, exclude=meta_constraint_names | meta_index_names,\n+                    index=True\n+                )\n+                unique_constraints = self._constraint_names(\n+                    model, columns, exclude=meta_constraint_names | meta_index_names,\n+                    unique=True\n+                )\n+                # Remove unique constraints from index list since unique constraints also act as indexes\n+                index_only_constraints = [name for name in all_indexes if name not in unique_constraints]\n+                if len(index_only_constraints) == 1:\n+                    constraint_name = index_only_constraints[0]\n+                else:\n+                    raise ValueError(\"Found wrong number (%s) of non-unique index constraints for %s(%s)\" % (\n+                        len(index_only_constraints),\n+                        model._meta.db_table,\n+                        \", \".join(columns),\n+                    ))\n+            else:\n+                # Fallback to original error for other constraint types\n+                raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n+                    len(constraint_names),\n+                    model._meta.db_table,\n+                    \", \".join(columns),\n+                ))\n+        else:\n+            # No constraints found\n             raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n                 len(constraint_names),\n                 model._meta.db_table,\n                 \", \".join(columns),\n             ))\n-        self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n+        \n+        self.execute(self._delete_constraint_sql(sql, model, constraint_name))\n \n     def alter_db_table(self, model, old_db_table, new_db_table):\n         \"\"\"Rename the table a model points to.\"\"\"\n"}
{"model_name_or_path": "ase_26", "instance_id": "django__django-12708", "model_patch": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 61f88401ab..4d89efd674 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -407,12 +407,62 @@ class BaseDatabaseSchemaEditor:\n             model, columns, exclude=meta_constraint_names | meta_index_names,\n             **constraint_kwargs\n         )\n+        \n         if len(constraint_names) != 1:\n-            raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n-                len(constraint_names),\n-                model._meta.db_table,\n-                \", \".join(columns),\n-            ))\n+            if len(constraint_names) == 0:\n+                # No constraints found - might be already deleted or not exist\n+                return\n+            \n+            # Multiple constraints found - need to be more specific\n+            # Determine what type of constraint we're trying to delete based on the SQL\n+            is_deleting_unique = sql == self.sql_delete_unique\n+            is_deleting_index = sql == self.sql_delete_index\n+            \n+            if is_deleting_unique:\n+                # When deleting unique constraints, get only unique constraints\n+                unique_constraints = self._constraint_names(\n+                    model, columns, exclude=meta_constraint_names | meta_index_names,\n+                    unique=True\n+                )\n+                if len(unique_constraints) == 1:\n+                    constraint_names = unique_constraints\n+            elif is_deleting_index:\n+                # When deleting index constraints, prefer non-unique indexes\n+                all_index_constraints = self._constraint_names(\n+                    model, columns, exclude=meta_constraint_names | meta_index_names,\n+                    index=True\n+                )\n+                unique_constraints = self._constraint_names(\n+                    model, columns, exclude=meta_constraint_names | meta_index_names,\n+                    unique=True\n+                )\n+                # Filter out unique constraints to get pure index constraints\n+                pure_index_constraints = [name for name in all_index_constraints \n+                                        if name not in unique_constraints]\n+                \n+                if len(pure_index_constraints) == 1:\n+                    constraint_names = pure_index_constraints\n+                elif len(all_index_constraints) == 1:\n+                    # If there's only one index constraint total, use it\n+                    constraint_names = all_index_constraints\n+            \n+            # Final check - if we still don't have exactly one constraint, raise error\n+            if len(constraint_names) != 1:\n+                constraint_type = \"unique\" if is_deleting_unique else \"index\" if is_deleting_index else \"unknown\"\n+                all_constraints = self._constraint_names(\n+                    model, columns, exclude=meta_constraint_names | meta_index_names\n+                )\n+                raise ValueError(\n+                    \"Found wrong number (%s) of constraints for %s(%s). \"\n+                    \"Expected exactly 1 %s constraint, but found constraints: %s\" % (\n+                        len(constraint_names),\n+                        model._meta.db_table,\n+                        \", \".join(columns),\n+                        constraint_type,\n+                        \", \".join(sorted(all_constraints))\n+                    )\n+                )\n+        \n         self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))\n \n     def alter_db_table(self, model, old_db_table, new_db_table):\n"}
